\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
org 100h


mov AH, 01h          ; wczytuje i jest na rejestrze al
int 21h


mov DL, AL           ; przepisuje na rejestr dl i wypisuje 
mov AH, 02h
int 21h


mov AX, 4C00h
int 21h
Jesli chcesz wczytac caly tekst i wypisac go

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

org 100h

mov ah,0Ah          ;do wczytania napisu
mov dx,buffer      ;przenosimy informacje do buffera
int 21h

mov ah, 02h         ;cale to jest troche dziwne
mov dl, 0Dh         ;ale po prostu polega na
int 21h                    ;wypisaniu spacji
mov dl, 0Ah
int 21h

;mov AH, 09h       ;latwiejszy sposob
;mov DX, tekst2   ;wypisania spacji tylko
;int 21h                   ;trzeba sobie go zrobic na dole

mov al,[buffer+4]  ;wypisuje 3 literke z buffera
mov dl,al                ;przenosimy informacje do dl 
mov ah,02h            ;zeby wypisalo
int 21h

mov ah,4Ch
int 21h

buffer db 20
;tekst2 db 0Ah,0Dh,"$"
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
org 100h

mov ah, 0Ah
mov dx, buffer
int 21h

mov ah, 02h
mov dl, 0Dh
int 21h
mov dl, 0Ah
int 21h

mov bl, [buffer+1] //
mov al, '$'
mov [buffer+2+bx], al

mov ah, 09h
mov dx, buffer+2
int 21h

mov ah, 4Ch
int 21h

buffer db 20
       
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
org 100h

; --- wczytaj string ---
mov ah, 0Ah
mov dx, buffer
int 21h

; --- nowa linia ---
mov ah, 02h
mov dl, 0Dh
int 21h
mov dl, 0Ah
int 21h

; --- pobierz d≥ugoúÊ ---
mov bl, [buffer+1]   ; BL = d≥ugoúÊ
shr bl, 1            ; BL = po≥owa d≥ugoúci

; zakoÒcz tekst znakiem '$' w po≥owie
mov byte [buffer+1+bx], '$'

; wypisz tylko pierwszπ po≥owÍ
mov ah, 09h
mov dx, buffer+2
int 21h

; koniec
mov ah, 4Ch
int 21h
buffer db 40
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

org 100h

mov ah, 0Ah
mov dx, buffer
int 21h

mov al, [buffer + 2]  ;pierwsza literka buffera
cmp al, '_'     ;to jest dla jumpa! sprawdza sobie!

jl mniejsze  ;jl (jesli mniejsze) 
je rowne      ;jl(jesli rowne)
jg wieksze  ;jg(jesli wieksze)

wieksze:
mov ah, 02h
mov dl, '>'
int 21h
jmp koniec  ;jmp po prostu skacze

mniejsze:
mov ah, 02h
mov dl, '<'
int 21h
jmp koniec

rowne:
mov ah, 02h
mov dl, '='
int 21h

koniec:
mov ah, 4Ch
int 21h

buffer db 2

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

org 100h

; ab / c -------> a b c /

push word [a]
push word [b]
pop BX    ;BX = a
pop AX    ;AX = b
mul BX    ;AX = ba
push AX  puszuje ax

push word [c]
pop BX      ;BX=c
pop AX     ;Ax = ba
mov DX, 0       ; DX musi byƒá wyzerowane
div BX         ;Ax = (ba)/c
push AX     ;puszuje

pop AX          ;AX = (ba)/c
mov [y], AX   y = AX

mov ax, 4C00h
int 21h

a dw 20
b dw 5
c dw 10
y dw 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

org 100h

; (A+B)‚àó(C‚àíD)/E -------> AB+CD-*E/


push word [a]
push word [b]
pop BX
pop AX
add AX,BX
push AX

push word [c]
push word [d]
pop BX
pop AX
sub AX,BX
push AX

pop BX
pop AX
mul BX
push AX

push word [e]
pop BX
pop AX
mov DX, 0
div BX
push AX


pop AX
mov [y], AX

mov ax, 4C00h
int 21h

a dw 3
b dw 5
c dw 10
d dw 3
e dw 2
y dw 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
org 100h 


mov ah, 02h  ;to zamienia na ten rejestr
mov bh,0    ;bh zmien na 0
mov dh,24   ;wiersz
mov dl,79    ;kolumna
int 10h    ;pamietaj ze tutaj jest int 10h

mov ah, 02h     ; wy≈õwietlenie jednego znaku
mov al, 2       ; liczba
add al, '0'     ; konwersja na ASCII
mov dl, al
int 21h


mov ax, 4C00h
int 21h



*****************************************

mov ah, 01h -- wczytuje l1znak do rejestru al
mov ah, 02h int 21 -- wypisuje znak z dl, musisz mov dl,al
mov ah,0Ah - wczyta do dx, jesli chcesz do buffor mov dx,buffer
mov AH, 09h - wypisuje co jest na dx, mozesz uzyc mov DX, buffer

tekst2 db 0Ah,0Dh,"$" // w sumie wazne bo to spacje robi
dodaj jeden -- INC AX
odejmij jeden -- DEC AX
dodawanie -- add Ax,Bx
odejmowanie -- sub Ax,Bx
mnozenie -- mul Bx (mnozy co jest na rejestrze Ax)
dzielenie -- mov Dx, 0 (wyzeruj dx)-- div Bx (dzieli co jest na rejestrze Ax) 

cmp Al, Bl

JE ‚Äì skok,gdyAroÃÅwneB
JNE ‚Äì skok, gdy A nieroÃÅwne B
JG ‚Äì skok,gdyAwieÃ®kszeodB
JGE ‚Äì skok, gdy A wieÃ®ksze lub roÃÅwne B
JA ‚Äì skok, gdy A wieÃ®ksze od B dla liczb bez znaku
JB ‚Äì skok, gdy A mniejsze od B dla liczb bez znaku
JG ‚Äì skok, gdy A wieÃ®ksze od B (ze znakiem)
JL ‚Äì skok, gdy A mniejsze od B (ze znakiem)
JLE - skok, gdy A mniejsze rowne od B
JMP ‚Äì zawsze skacze

********************************************




org 100h

mov ah, 01h
int 21h

mov AH, 09h       ;latwiejszy sposob
mov DX, tekst2   ;wypisania spacji tylko
int 21h     

cmp al,0x20

jl error

cmp al, 0x3F

jle dziesiec

cmp al, 0x5F

jle siedem

cmp al, 0x7E

jle minus

jmp error


minus:
sub al, 12
mov ah, 02h
mov dl, al
int 21h
jmp koniec


siedem:
add al, 7
mov ah, 02h
mov dl, al
int 21h
jmp koniec


dziesiec:
add al, 10
mov ah, 02h
mov dl, al
int 21h
jmp koniec


error:
mov ah, 09h
mov dx, napiserror
int 21h
jmp koniec



koniec:
mov AX, 4C00h
int 21h


napiserror db 'NapisError$'
tekst2 db 0Ah,0Dh,"$"






